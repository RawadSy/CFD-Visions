<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CFD Streamlines Background</title>
  <style>
    :root {
      --bg:#0b1020; /* deep navy */
    }
    html, body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial;
    }
    /* The canvas sits behind your page content */
    #flow {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      z-index: -1;
      background: radial-gradient(1200px 800px at 70% 30%, #141b33 0%, #0b1020 60%, #070a15 100%);
    }
    /* Optional overlay text to demo foreground content */
    .overlay {
      position: relative;
      z-index: 1;
      color: #e9eefc;
      padding: clamp(16px, 4vw, 64px);
      max-width: 900px;
      line-height: 1.6;
      text-shadow: 0 1px 2px rgba(0,0,0,.5);
    }
    .overlay h1{
      font-size: clamp(28px, 6vw, 56px);
      margin: 0 0 .25em 0;
      letter-spacing: .5px;
    }
    .overlay p{opacity:.9}
    .pill{
      display:inline-block;border:1px solid #2a3a6b;padding:.35em .75em;border-radius:999px;font-size:.85rem;opacity:.85
    }
  </style>
</head>
<body>
  <canvas id="flow"></canvas>
  <!-- Optional: demo foreground content (remove on your site) -->
  <div class="overlay">
    <span class="pill">CFD • Streamlines • Heat Transfer</span>
    <h1>Shell & Tube • Flow Around Cylinder</h1>
    <p>GPU-like particle advection on Canvas 2D. Streamlines bend around a virtual cylinder; color encodes temperature (blue → red) based on local speed and a mild thermal gradient.</p>
  </div>

  <script>
  // ==========================
  // CFD Streamlines Background
  // - Vector field: potential flow around a cylinder + gentle vortex noise
  // - Rendering: many particles with trails (alpha fade) on 2D canvas
  // - Interaction: mouse perturbs the field locally
  // ==========================

  const canvas = document.getElementById('flow');
  const ctx = canvas.getContext('2d');
  let W = canvas.width = window.innerWidth;
  let H = canvas.height = window.innerHeight;
  let dpr = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = W * dpr; canvas.height = H * dpr; canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  const TAU = Math.PI * 2;
  const rand = (a=0,b=1)=>a+Math.random()*(b-a);

  // Parameters
  const params = {
    particles: Math.floor(Math.min(1800, (W*H)/600)), // scale with screen size
    step: 0.0028,           // integration step in normalized space
    speedScale: 0.75,       // scales vector field magnitude
    cylinderRadius: 0.18,   // radius in NDC (normalized device coords)
    fade: 0.09,             // 0..1 higher = shorter trails
    mouseInfluence: 0.22,   // perturbation strength
    fieldWobble: 0.25,      // noise wobble amount
    thermalGradient: 0.35,  // amount of color shift with x
  };

  // Mouse interaction
  const mouse = {x: W*0.65, y: H*0.4, down:false};
  window.addEventListener('pointermove', e=>{mouse.x=e.clientX; mouse.y=e.clientY});
  window.addEventListener('pointerdown', ()=>mouse.down=true);
  window.addEventListener('pointerup', ()=>mouse.down=false);

  // Map pixels to normalized space [-1,1] with aspect correction
  function toNDC(px, py){
    const ax = (px / W) * 2 - 1;
    const ay = (py / H) * 2 - 1;
    const aspect = W/H;
    return {x: ax*aspect, y: -ay}; // y up
  }

  // Simple hash noise (value noise) for gentle vortices
  function hash2d(x,y){
    const s = Math.sin(x*127.1 + y*311.7) * 43758.5453;
    return s - Math.floor(s);
  }
  function noise(x,y){
    const xi = Math.floor(x), yi = Math.floor(y);
    const xf = x - xi,       yf = y - yi;
    const u = xf*xf*(3-2*xf);
    const v = yf*yf*(3-2*yf);
    const n00 = hash2d(xi,yi),   n10 = hash2d(xi+1,yi);
    const n01 = hash2d(xi,yi+1), n11 = hash2d(xi+1,yi+1);
    const nx0 = n00*(1-u)+n10*u;
    const nx1 = n01*(1-u)+n11*u;
    return nx0*(1-v)+nx1*v;
  }

  // Curl-like small perturbation for turbulence feel
  function vortex(x,y,t){
    const s = 0.9; // spatial frequency
    const n1 = noise(x*s+ t*0.1, y*s- t*0.07);
    const n2 = noise(x*s- t*0.08, y*s+ t*0.09);
    // pseudo curl of two scalar fields
    return { vx: (n2 - 0.5), vy: -(n1 - 0.5) };
  }

  // Potential flow around a cylinder at origin with freestream U in +x
  function flowAroundCylinder(x, y){
    const a = params.cylinderRadius;
    const U = 1.0;
    const r2 = x*x + y*y;
    const r = Math.sqrt(r2) + 1e-6;
    const theta = Math.atan2(y, x);

    // Avoid singularity inside cylinder: clamp r to boundary
    const rc = Math.max(r, a*1.02);

    const Vr = U * (1 - (a*a)/(rc*rc)) * Math.cos(theta);
    const Vt = -U * (1 + (a*a)/(rc*rc)) * Math.sin(theta);

    // Convert polar to Cartesian
    const cosT = Math.cos(theta), sinT = Math.sin(theta);
    const u = Vr*cosT - Vt*sinT;
    const v = Vr*sinT + Vt*cosT;

    return {u, v};
  }

  // Add local mouse perturbation (like stirring)
  function mouseField(x,y){
    const m = toNDC(mouse.x, mouse.y);
    const dx = x - m.x, dy = y - m.y;
    const r2 = dx*dx + dy*dy;
    const R = 0.12; // influence radius
    const k = Math.exp(-r2/(R*R));
    // tangential swirl around mouse
    return {u: -dy * k * (mouse.down? 6 : 2), v: dx * k * (mouse.down? 6 : 2)};
  }

  // Combined vector field
  function field(x, y, t){
    const base = flowAroundCylinder(x, y);
    const vort = vortex(x*2, y*2, t);
    const mouseV = mouseField(x,y);
    let u = base.u + params.fieldWobble * vort.vx + mouseV.u;
    let v = base.v + params.fieldWobble * vort.vy + mouseV.v;
    return {u, v};
  }

  // Particles
  const P = [];
  function resetParticle(p){
    // spawn upstream (left) or randomly
    if (Math.random() < 0.7){
      p.x = - (W/H) - rand(0.0, .2);
      p.y = rand(-1, 1);
    } else {
      p.x = rand(-(W/H), (W/H));
      p.y = rand(-1, 1);
    }
    p.life = rand(2, 8);
    p.age = 0;
  }

  function initParticles(){
    P.length = 0;
    for (let i=0;i<params.particles;i++){
      const p = {x:0,y:0,px:0,py:0, age:0, life:0};
      resetParticle(p);
      p.px = p.x; p.py = p.y;
      P.push(p);
    }
  }

  // Color mapping: blue (cold) to red (hot) by speed & x position (thermal gradient)
  function drawSegment(x1,y1,x2,y2, speed, xNorm){
    const heat = Math.min(1, Math.max(0, 0.35 + 0.45*speed + params.thermalGradient*(xNorm*0.5+0.5)));
    // Map heat to HSL: 220° (blue) -> 0° (red)
    const h = 220 - 220*heat; // 220..0
    ctx.strokeStyle = `hsl(${h} 100% 60% / 0.9)`;
    ctx.beginPath();
    const sx1 = ((x1/(W/H)) * 0.5 + 0.5) * W; // back from NDC to px
    const sy1 = ((-y1) * 0.5 + 0.5) * H;
    const sx2 = ((x2/(W/H)) * 0.5 + 0.5) * W;
    const sy2 = ((-y2) * 0.5 + 0.5) * H;
    ctx.moveTo(sx1, sy1);
    ctx.lineTo(sx2, sy2);
    ctx.stroke();
  }

  // Cylinder overlay for reference (soft glow)
  function drawCylinder(){
    const a = params.cylinderRadius;
    ctx.save();
    ctx.translate(W*0.5, H*0.5);
    const rPix = a * H; // because y is normalized to [-1,1]
    const gradient = ctx.createRadialGradient(0,0,rPix*0.6, 0,0,rPix*1.1);
    gradient.addColorStop(0, 'rgba(180,210,255,0.08)');
    gradient.addColorStop(1, 'rgba(20,30,60,0)');
    ctx.fillStyle = gradient;
    ctx.beginPath(); ctx.arc(0,0,rPix,0,TAU); ctx.fill();

    ctx.strokeStyle = 'rgba(120,160,255,0.25)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(0,0,rPix,0,TAU); ctx.stroke();
    ctx.restore();
  }

  // Render loop
  let last = performance.now();
  function frame(now){
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;

    // fade trails
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = `rgba(11, 16, 32, ${params.fade})`;
    ctx.fillRect(0,0,W,H);

    const aspect = W/H;
    const t = now * 0.0015;

    ctx.lineWidth = 1.2;
    ctx.globalCompositeOperation = 'lighter';

    for (let i=0;i<P.length;i++){
      const p = P[i];
      // Advect particle with simple RK2 (midpoint)
      const v1 = field(p.x, p.y, t);
      const xMid = p.x + v1.u * params.step * 0.5 * params.speedScale;
      const yMid = p.y + v1.v * params.step * 0.5 * params.speedScale;
      const v2 = field(xMid, yMid, t);
      const u = v2.u * params.speedScale;
      const v = v2.v * params.speedScale;

      const xPrev = p.x, yPrev = p.y;
      p.x += u * params.step;
      p.y += v * params.step;
      p.age += dt;

      // kill if out of bounds or too old or inside cylinder
      const r2 = p.x*p.x + p.y*p.y;
      if (p.age > p.life || Math.abs(p.x) > aspect+0.2 || Math.abs(p.y) > 1.2 || r2 < (params.cylinderRadius*params.cylinderRadius*1.02)){
        resetParticle(p);
        p.px = p.x; p.py = p.y;
        continue;
      }

      const speed = Math.min(1.4, Math.hypot(u,v));
      drawSegment(xPrev, yPrev, p.x, p.y, speed, p.x/aspect);

      p.px = p.x; p.py = p.y;
    }

    drawCylinder();

    requestAnimationFrame(frame);
  }

  // Init & start
  initParticles();
  requestAnimationFrame(frame);

  // Resize handling
  window.addEventListener('resize', ()=>{
    W = window.innerWidth; H = window.innerHeight;
    canvas.width = W * dpr; canvas.height = H * dpr; canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    initParticles();
  });
  </script>
</body>
</html>
